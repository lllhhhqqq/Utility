抽象出一个可用的内存分配器
如果采用共享内存，就大块分配内存，构造一个环形队列，供多个进程使用，多个进程之间的通信采用原子操作来同步处理
可以和管道比较一下效率（管道应该是采用共享内存的）
应该支持format中的序列化反序列化操作的接口，要抽象出（包装）一个通道的概念，通道可以是tuple里面的模板元
* 支持多线程 和多进程同时操作一个通道 （要仔细考虑，数据结构，和同步操作的方式）
现在初步的构思是以进程为单位 一条通道至少对应一对读写进程 读写进程分别获得自己的读写偏移（这是原子数据） 对偏移进行重新计算 然后写入或者读取内存
采用环形队列，但是当中的数据采用数组的形式，能写入的单个包能写入数据的最大长度支持到单个内存块*数组的长度，这个是单个包的最大长度，采用这种处理是
规避掉了多个进程或者多个线程处理同一个通道的同步问题，每个原子单位要做的事情就是获得原子的偏移量，并且原子的去设置这个偏移量
写的流程就是 单个元素原子获得写的偏移 计算要写多少内存块（判断是否可写），内存偏移重新写入写的偏移 对内存进行序列化写入
读的流程就是 单个元素原子获得读的偏移 计算要读多少内存块 ，内存偏移重新写入读的偏移 对内存进行序列化复制 （共享内存不考虑直接进行偏移量的映射）
不考虑映射一个是环形队列的问题 内存不可能是无限大的 而内存的生命周期不容易确定 同样stl之类的存在同样的问题
要处理这些问题应该在更低层次的内存处理模块来实现
/////////////////////////////////////////////////////////////////////////////////////////////////////
完成之后可以考虑iocp 来构建通信层
linux可以采用 kqueue 和epoll来构建通信层 
可以通过这种方式来直接通知要读写多少个字节以及用什么方法去读（这部分有待考虑）
/////////////////////////////////////////////////////////////////////////////////////////////////////
抽象一层适配器，用来定位内存和最大长度,内存写用chunk来表示
/////
调整tuple的方法使tuple的in和out分离出来，默认是同一个in out 也可以拆成两个 不同的in和不同的out
////
优化掉引用类型的长度写入，和长度读取的过程，因为已经知道类型的情况下可以不用读取长度
////
退出的时候调整释放问题，所有的资源都在主线程释放


